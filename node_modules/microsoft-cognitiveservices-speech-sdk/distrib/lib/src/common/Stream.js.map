{"version":3,"sources":["src/common/Stream.ts"],"names":[],"mappings":"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","file":"Stream.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { InvalidOperationError } from \"./Error\";\r\nimport { createNoDashGuid } from \"./Guid\";\r\nimport { IStringDictionary } from \"./IDictionary\";\r\nimport { Promise } from \"./Promise\";\r\nimport { Queue } from \"./Queue\";\r\nimport { IStreamChunk } from \"./Stream\";\r\n\r\nexport interface IStreamChunk<TBuffer> {\r\n    isEnd: boolean;\r\n    buffer: TBuffer;\r\n    timeReceived: number;\r\n}\r\n\r\nexport class Stream<TBuffer> {\r\n    private privId: string;\r\n    private privReaderIdCounter: number = 1;\r\n    private privStreambuffer: Array<IStreamChunk<TBuffer>>;\r\n    private privIsEnded: boolean = false;\r\n    private privReaderQueues: IStringDictionary<Queue<IStreamChunk<TBuffer>>>;\r\n\r\n    public constructor(streamId?: string) {\r\n        this.privId = streamId ? streamId : createNoDashGuid();\r\n        this.privStreambuffer = [];\r\n        this.privReaderQueues = {};\r\n    }\r\n\r\n    public get isClosed(): boolean {\r\n        return this.privIsEnded;\r\n    }\r\n\r\n    public get id(): string {\r\n        return this.privId;\r\n    }\r\n\r\n    public getReader = (): StreamReader<TBuffer> => {\r\n        const readerId = this.privReaderIdCounter;\r\n        this.privReaderIdCounter++;\r\n        const readerQueue = new Queue<IStreamChunk<TBuffer>>();\r\n        const currentLength = this.privStreambuffer.length;\r\n        this.privReaderQueues[readerId] = readerQueue;\r\n        for (let i = 0; i < currentLength; i++) {\r\n            readerQueue.enqueue(this.privStreambuffer[i]);\r\n        }\r\n        return new StreamReader(\r\n            this.privId,\r\n            readerQueue,\r\n            () => {\r\n                delete this.privReaderQueues[readerId];\r\n            });\r\n    }\r\n\r\n    public close(): void {\r\n        if (!this.privIsEnded) {\r\n            this.writeStreamChunk({\r\n                buffer: null,\r\n                isEnd: true,\r\n                timeReceived: Date.now(),\r\n            });\r\n            this.privIsEnded = true;\r\n        }\r\n    }\r\n\r\n    public writeStreamChunk(streamChunk: IStreamChunk<TBuffer>): void {\r\n        this.throwIfClosed();\r\n        this.privStreambuffer.push(streamChunk);\r\n        for (const readerId in this.privReaderQueues) {\r\n            if (!this.privReaderQueues[readerId].isDisposed()) {\r\n                try {\r\n                    this.privReaderQueues[readerId].enqueue(streamChunk);\r\n                } catch (e) {\r\n                    // Do nothing\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private throwIfClosed = (): void => {\r\n        if (this.privIsEnded) {\r\n            throw new InvalidOperationError(\"Stream closed\");\r\n        }\r\n    }\r\n}\r\n\r\n// tslint:disable-next-line:max-classes-per-file\r\nexport class StreamReader<TBuffer> {\r\n    private privReaderQueue: Queue<IStreamChunk<TBuffer>>;\r\n    private privOnClose: () => void;\r\n    private privIsClosed: boolean = false;\r\n    private privStreamId: string;\r\n\r\n    public constructor(streamId: string, readerQueue: Queue<IStreamChunk<TBuffer>>, onClose: () => void) {\r\n        this.privReaderQueue = readerQueue;\r\n        this.privOnClose = onClose;\r\n        this.privStreamId = streamId;\r\n    }\r\n\r\n    public get isClosed(): boolean {\r\n        return this.privIsClosed;\r\n    }\r\n\r\n    public get streamId(): string {\r\n        return this.privStreamId;\r\n    }\r\n\r\n    public read = (): Promise<IStreamChunk<TBuffer>> => {\r\n        if (this.isClosed) {\r\n            throw new InvalidOperationError(\"StreamReader closed\");\r\n        }\r\n\r\n        return this.privReaderQueue\r\n            .dequeue()\r\n            .onSuccessContinueWith((streamChunk: IStreamChunk<TBuffer>) => {\r\n                if (streamChunk.isEnd) {\r\n                    this.privReaderQueue.dispose(\"End of stream reached\");\r\n                }\r\n\r\n                return streamChunk;\r\n            });\r\n    }\r\n\r\n    public close = (): void => {\r\n        if (!this.privIsClosed) {\r\n            this.privIsClosed = true;\r\n            this.privReaderQueue.dispose(\"StreamReader closed\");\r\n            this.privOnClose();\r\n        }\r\n    }\r\n}\r\n"]}