{"version":3,"sources":["src/common.browser/FileAudioSource.ts"],"names":[],"mappings":"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","file":"FileAudioSource.js","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { AudioStreamFormat, AudioStreamFormatImpl } from \"../../src/sdk/Audio/AudioStreamFormat\";\r\nimport {\r\n    connectivity,\r\n    ISpeechConfigAudioDevice,\r\n    type,\r\n} from \"../common.speech/Exports\";\r\nimport {\r\n    AudioSourceErrorEvent,\r\n    AudioSourceEvent,\r\n    AudioSourceInitializingEvent,\r\n    AudioSourceOffEvent,\r\n    AudioSourceReadyEvent,\r\n    AudioStreamNodeAttachedEvent,\r\n    AudioStreamNodeAttachingEvent,\r\n    AudioStreamNodeDetachedEvent,\r\n    AudioStreamNodeErrorEvent,\r\n    createNoDashGuid,\r\n    Events,\r\n    EventSource,\r\n    IAudioSource,\r\n    IAudioStreamNode,\r\n    IStringDictionary,\r\n    Promise,\r\n    PromiseHelper,\r\n    Stream,\r\n    StreamReader,\r\n} from \"../common/Exports\";\r\n\r\nexport class FileAudioSource implements IAudioSource {\r\n\r\n    // Recommended sample rate (bytes/second).\r\n    private static readonly SAMPLE_RATE: number = 16000 * 2; // 16 kHz * 16 bits\r\n\r\n    // We should stream audio at no faster than 2x real-time (i.e., send five chunks\r\n    // per second, with the chunk size == sample rate in bytes per second * 2 / 5).\r\n    private static readonly CHUNK_SIZE: number = FileAudioSource.SAMPLE_RATE * 2 / 5;\r\n\r\n    // 10 seconds of audio in bytes =\r\n    // sample rate (bytes/second) * 600 (seconds) + 44 (size of the wave header).\r\n    private static readonly MAX_SIZE: number = FileAudioSource.SAMPLE_RATE * 600 + 44;\r\n\r\n    private static readonly FILEFORMAT: AudioStreamFormatImpl = AudioStreamFormat.getWaveFormatPCM(16000, 16, 1) as AudioStreamFormatImpl;\r\n\r\n    private privStreams: IStringDictionary<Stream<ArrayBuffer>> = {};\r\n\r\n    private privId: string;\r\n\r\n    private privEvents: EventSource<AudioSourceEvent>;\r\n\r\n    private privFile: File;\r\n\r\n    public constructor(file: File, audioSourceId?: string) {\r\n        this.privId = audioSourceId ? audioSourceId : createNoDashGuid();\r\n        this.privEvents = new EventSource<AudioSourceEvent>();\r\n        this.privFile = file;\r\n    }\r\n\r\n    public get format(): AudioStreamFormat {\r\n        return FileAudioSource.FILEFORMAT;\r\n    }\r\n\r\n    public turnOn = (): Promise<boolean> => {\r\n        if (typeof FileReader === \"undefined\") {\r\n            const errorMsg = \"Browser does not support FileReader.\";\r\n            this.onEvent(new AudioSourceErrorEvent(errorMsg, \"\")); // initialization error - no streamid at this point\r\n            return PromiseHelper.fromError<boolean>(errorMsg);\r\n        } else if (this.privFile.name.lastIndexOf(\".wav\") !== this.privFile.name.length - 4) {\r\n            const errorMsg = this.privFile.name + \" is not supported. Only WAVE files are allowed at the moment.\";\r\n            this.onEvent(new AudioSourceErrorEvent(errorMsg, \"\"));\r\n            return PromiseHelper.fromError<boolean>(errorMsg);\r\n        } else if (this.privFile.size > FileAudioSource.MAX_SIZE) {\r\n            const errorMsg = this.privFile.name + \" exceeds the maximum allowed file size (\" + FileAudioSource.MAX_SIZE + \").\";\r\n            this.onEvent(new AudioSourceErrorEvent(errorMsg, \"\"));\r\n            return PromiseHelper.fromError<boolean>(errorMsg);\r\n        }\r\n\r\n        this.onEvent(new AudioSourceInitializingEvent(this.privId)); // no stream id\r\n        this.onEvent(new AudioSourceReadyEvent(this.privId));\r\n        return PromiseHelper.fromResult(true);\r\n    }\r\n\r\n    public id = (): string => {\r\n        return this.privId;\r\n    }\r\n\r\n    public attach = (audioNodeId: string): Promise<IAudioStreamNode> => {\r\n        this.onEvent(new AudioStreamNodeAttachingEvent(this.privId, audioNodeId));\r\n\r\n        return this.upload(audioNodeId).onSuccessContinueWith<IAudioStreamNode>(\r\n            (streamReader: StreamReader<ArrayBuffer>) => {\r\n                this.onEvent(new AudioStreamNodeAttachedEvent(this.privId, audioNodeId));\r\n                return {\r\n                    detach: () => {\r\n                        streamReader.close();\r\n                        delete this.privStreams[audioNodeId];\r\n                        this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\r\n                        this.turnOff();\r\n                    },\r\n                    id: () => {\r\n                        return audioNodeId;\r\n                    },\r\n                    read: () => {\r\n                        return streamReader.read();\r\n                    },\r\n                };\r\n            });\r\n    }\r\n\r\n    public detach = (audioNodeId: string): void => {\r\n        if (audioNodeId && this.privStreams[audioNodeId]) {\r\n            this.privStreams[audioNodeId].close();\r\n            delete this.privStreams[audioNodeId];\r\n            this.onEvent(new AudioStreamNodeDetachedEvent(this.privId, audioNodeId));\r\n        }\r\n    }\r\n\r\n    public turnOff = (): Promise<boolean> => {\r\n        for (const streamId in this.privStreams) {\r\n            if (streamId) {\r\n                const stream = this.privStreams[streamId];\r\n                if (stream && !stream.isClosed) {\r\n                    stream.close();\r\n                }\r\n            }\r\n        }\r\n\r\n        this.onEvent(new AudioSourceOffEvent(this.privId)); // no stream now\r\n        return PromiseHelper.fromResult(true);\r\n    }\r\n\r\n    public get events(): EventSource<AudioSourceEvent> {\r\n        return this.privEvents;\r\n    }\r\n\r\n    public get deviceInfo(): Promise<ISpeechConfigAudioDevice> {\r\n        return PromiseHelper.fromResult({\r\n            bitspersample: FileAudioSource.FILEFORMAT.bitsPerSample,\r\n            channelcount: FileAudioSource.FILEFORMAT.channels,\r\n            connectivity: connectivity.Unknown,\r\n            manufacturer: \"Speech SDK\",\r\n            model: \"File\",\r\n            samplerate: FileAudioSource.FILEFORMAT.samplesPerSec,\r\n            type: type.File,\r\n        });\r\n    }\r\n\r\n    private upload = (audioNodeId: string): Promise<StreamReader<ArrayBuffer>> => {\r\n        return this.turnOn()\r\n            .onSuccessContinueWith<StreamReader<ArrayBuffer>>((_: boolean) => {\r\n                const stream = new Stream<ArrayBuffer>(audioNodeId);\r\n\r\n                this.privStreams[audioNodeId] = stream;\r\n\r\n                const reader: FileReader = new FileReader();\r\n\r\n                let startOffset = 0;\r\n                let endOffset = FileAudioSource.CHUNK_SIZE;\r\n\r\n                const processNextChunk = (event: Event): void => {\r\n                    if (stream.isClosed) {\r\n                        return; // output stream was closed (somebody called TurnOff). We're done here.\r\n                    }\r\n\r\n                    stream.writeStreamChunk({\r\n                        buffer: reader.result as ArrayBuffer,\r\n                        isEnd: false,\r\n                        timeReceived: Date.now(),\r\n                    });\r\n\r\n                    if (endOffset < this.privFile.size) {\r\n                        startOffset = endOffset;\r\n                        endOffset = Math.min(endOffset + FileAudioSource.CHUNK_SIZE, this.privFile.size);\r\n                        const chunk = this.privFile.slice(startOffset, endOffset);\r\n                        reader.readAsArrayBuffer(chunk);\r\n                    } else {\r\n                        // we've written the entire file to the output stream, can close it now.\r\n                        stream.close();\r\n                    }\r\n                };\r\n\r\n                reader.onload = processNextChunk;\r\n\r\n                reader.onerror = (event: ProgressEvent) => {\r\n                    const errorMsg = `Error occurred while processing '${this.privFile.name}'. ${event}`;\r\n                    this.onEvent(new AudioStreamNodeErrorEvent(this.privId, audioNodeId, errorMsg));\r\n                    throw new Error(errorMsg);\r\n                };\r\n\r\n                const chunk = this.privFile.slice(startOffset, endOffset);\r\n                reader.readAsArrayBuffer(chunk);\r\n\r\n                return stream.getReader();\r\n            });\r\n    }\r\n\r\n    private onEvent = (event: AudioSourceEvent): void => {\r\n        this.privEvents.onEvent(event);\r\n        Events.instance.onEvent(event);\r\n    }\r\n}\r\n"]}