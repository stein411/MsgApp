{"version":3,"sources":["src/common/Stream.ts"],"names":[],"mappings":"AAMA,OAAO,EAAE,OAAO,EAAE,MAAM,WAAW,CAAC;AACpC,OAAO,EAAE,KAAK,EAAE,MAAM,SAAS,CAAC;AAChC,OAAO,EAAE,YAAY,EAAE,MAAM,UAAU,CAAC;AAExC,MAAM,WAAW,YAAY,CAAC,OAAO;IACjC,KAAK,EAAE,OAAO,CAAC;IACf,MAAM,EAAE,OAAO,CAAC;IAChB,YAAY,EAAE,MAAM,CAAC;CACxB;AAED,qBAAa,MAAM,CAAC,OAAO;IACvB,OAAO,CAAC,MAAM,CAAS;IACvB,OAAO,CAAC,mBAAmB,CAAa;IACxC,OAAO,CAAC,gBAAgB,CAA+B;IACvD,OAAO,CAAC,WAAW,CAAkB;IACrC,OAAO,CAAC,gBAAgB,CAAkD;gBAEvD,QAAQ,CAAC,EAAE,MAAM;aAMzB,QAAQ,EAAI,OAAO;aAInB,EAAE,EAAI,MAAM;IAIhB,SAAS,8BAef;IAEM,KAAK,IAAI,IAAI;IAWb,gBAAgB,CAAC,WAAW,EAAE,YAAY,CAAC,OAAO,CAAC,GAAG,IAAI;IAcjE,OAAO,CAAC,aAAa,CAIpB;CACJ;AAGD,qBAAa,YAAY,CAAC,OAAO;IAC7B,OAAO,CAAC,eAAe,CAA+B;IACtD,OAAO,CAAC,WAAW,CAAa;IAChC,OAAO,CAAC,YAAY,CAAkB;IACtC,OAAO,CAAC,YAAY,CAAS;gBAEV,QAAQ,EAAE,MAAM,EAAE,WAAW,EAAE,KAAK,CAAC,YAAY,CAAC,OAAO,CAAC,CAAC,EAAE,OAAO,EAAE,MAAM,IAAI;aAMxF,QAAQ,EAAI,OAAO;aAInB,QAAQ,EAAI,MAAM;IAItB,IAAI,uCAcV;IAEM,KAAK,aAMX;CACJ","file":"Stream.d.ts","sourcesContent":["// Copyright (c) Microsoft Corporation. All rights reserved.\r\n// Licensed under the MIT license.\r\n\r\nimport { InvalidOperationError } from \"./Error\";\r\nimport { createNoDashGuid } from \"./Guid\";\r\nimport { IStringDictionary } from \"./IDictionary\";\r\nimport { Promise } from \"./Promise\";\r\nimport { Queue } from \"./Queue\";\r\nimport { IStreamChunk } from \"./Stream\";\r\n\r\nexport interface IStreamChunk<TBuffer> {\r\n    isEnd: boolean;\r\n    buffer: TBuffer;\r\n    timeReceived: number;\r\n}\r\n\r\nexport class Stream<TBuffer> {\r\n    private privId: string;\r\n    private privReaderIdCounter: number = 1;\r\n    private privStreambuffer: Array<IStreamChunk<TBuffer>>;\r\n    private privIsEnded: boolean = false;\r\n    private privReaderQueues: IStringDictionary<Queue<IStreamChunk<TBuffer>>>;\r\n\r\n    public constructor(streamId?: string) {\r\n        this.privId = streamId ? streamId : createNoDashGuid();\r\n        this.privStreambuffer = [];\r\n        this.privReaderQueues = {};\r\n    }\r\n\r\n    public get isClosed(): boolean {\r\n        return this.privIsEnded;\r\n    }\r\n\r\n    public get id(): string {\r\n        return this.privId;\r\n    }\r\n\r\n    public getReader = (): StreamReader<TBuffer> => {\r\n        const readerId = this.privReaderIdCounter;\r\n        this.privReaderIdCounter++;\r\n        const readerQueue = new Queue<IStreamChunk<TBuffer>>();\r\n        const currentLength = this.privStreambuffer.length;\r\n        this.privReaderQueues[readerId] = readerQueue;\r\n        for (let i = 0; i < currentLength; i++) {\r\n            readerQueue.enqueue(this.privStreambuffer[i]);\r\n        }\r\n        return new StreamReader(\r\n            this.privId,\r\n            readerQueue,\r\n            () => {\r\n                delete this.privReaderQueues[readerId];\r\n            });\r\n    }\r\n\r\n    public close(): void {\r\n        if (!this.privIsEnded) {\r\n            this.writeStreamChunk({\r\n                buffer: null,\r\n                isEnd: true,\r\n                timeReceived: Date.now(),\r\n            });\r\n            this.privIsEnded = true;\r\n        }\r\n    }\r\n\r\n    public writeStreamChunk(streamChunk: IStreamChunk<TBuffer>): void {\r\n        this.throwIfClosed();\r\n        this.privStreambuffer.push(streamChunk);\r\n        for (const readerId in this.privReaderQueues) {\r\n            if (!this.privReaderQueues[readerId].isDisposed()) {\r\n                try {\r\n                    this.privReaderQueues[readerId].enqueue(streamChunk);\r\n                } catch (e) {\r\n                    // Do nothing\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    private throwIfClosed = (): void => {\r\n        if (this.privIsEnded) {\r\n            throw new InvalidOperationError(\"Stream closed\");\r\n        }\r\n    }\r\n}\r\n\r\n// tslint:disable-next-line:max-classes-per-file\r\nexport class StreamReader<TBuffer> {\r\n    private privReaderQueue: Queue<IStreamChunk<TBuffer>>;\r\n    private privOnClose: () => void;\r\n    private privIsClosed: boolean = false;\r\n    private privStreamId: string;\r\n\r\n    public constructor(streamId: string, readerQueue: Queue<IStreamChunk<TBuffer>>, onClose: () => void) {\r\n        this.privReaderQueue = readerQueue;\r\n        this.privOnClose = onClose;\r\n        this.privStreamId = streamId;\r\n    }\r\n\r\n    public get isClosed(): boolean {\r\n        return this.privIsClosed;\r\n    }\r\n\r\n    public get streamId(): string {\r\n        return this.privStreamId;\r\n    }\r\n\r\n    public read = (): Promise<IStreamChunk<TBuffer>> => {\r\n        if (this.isClosed) {\r\n            throw new InvalidOperationError(\"StreamReader closed\");\r\n        }\r\n\r\n        return this.privReaderQueue\r\n            .dequeue()\r\n            .onSuccessContinueWith((streamChunk: IStreamChunk<TBuffer>) => {\r\n                if (streamChunk.isEnd) {\r\n                    this.privReaderQueue.dispose(\"End of stream reached\");\r\n                }\r\n\r\n                return streamChunk;\r\n            });\r\n    }\r\n\r\n    public close = (): void => {\r\n        if (!this.privIsClosed) {\r\n            this.privIsClosed = true;\r\n            this.privReaderQueue.dispose(\"StreamReader closed\");\r\n            this.privOnClose();\r\n        }\r\n    }\r\n}\r\n"]}