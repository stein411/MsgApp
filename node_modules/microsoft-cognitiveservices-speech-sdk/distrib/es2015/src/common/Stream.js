// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT license.
import { InvalidOperationError } from "./Error";
import { createNoDashGuid } from "./Guid";
import { Queue } from "./Queue";
export class Stream {
    constructor(streamId) {
        this.privReaderIdCounter = 1;
        this.privIsEnded = false;
        this.getReader = () => {
            const readerId = this.privReaderIdCounter;
            this.privReaderIdCounter++;
            const readerQueue = new Queue();
            const currentLength = this.privStreambuffer.length;
            this.privReaderQueues[readerId] = readerQueue;
            for (let i = 0; i < currentLength; i++) {
                readerQueue.enqueue(this.privStreambuffer[i]);
            }
            return new StreamReader(this.privId, readerQueue, () => {
                delete this.privReaderQueues[readerId];
            });
        };
        this.throwIfClosed = () => {
            if (this.privIsEnded) {
                throw new InvalidOperationError("Stream closed");
            }
        };
        this.privId = streamId ? streamId : createNoDashGuid();
        this.privStreambuffer = [];
        this.privReaderQueues = {};
    }
    get isClosed() {
        return this.privIsEnded;
    }
    get id() {
        return this.privId;
    }
    close() {
        if (!this.privIsEnded) {
            this.writeStreamChunk({
                buffer: null,
                isEnd: true,
                timeReceived: Date.now(),
            });
            this.privIsEnded = true;
        }
    }
    writeStreamChunk(streamChunk) {
        this.throwIfClosed();
        this.privStreambuffer.push(streamChunk);
        for (const readerId in this.privReaderQueues) {
            if (!this.privReaderQueues[readerId].isDisposed()) {
                try {
                    this.privReaderQueues[readerId].enqueue(streamChunk);
                }
                catch (e) {
                    // Do nothing
                }
            }
        }
    }
}
// tslint:disable-next-line:max-classes-per-file
export class StreamReader {
    constructor(streamId, readerQueue, onClose) {
        this.privIsClosed = false;
        this.read = () => {
            if (this.isClosed) {
                throw new InvalidOperationError("StreamReader closed");
            }
            return this.privReaderQueue
                .dequeue()
                .onSuccessContinueWith((streamChunk) => {
                if (streamChunk.isEnd) {
                    this.privReaderQueue.dispose("End of stream reached");
                }
                return streamChunk;
            });
        };
        this.close = () => {
            if (!this.privIsClosed) {
                this.privIsClosed = true;
                this.privReaderQueue.dispose("StreamReader closed");
                this.privOnClose();
            }
        };
        this.privReaderQueue = readerQueue;
        this.privOnClose = onClose;
        this.privStreamId = streamId;
    }
    get isClosed() {
        return this.privIsClosed;
    }
    get streamId() {
        return this.privStreamId;
    }
}

//# sourceMappingURL=Stream.js.map
